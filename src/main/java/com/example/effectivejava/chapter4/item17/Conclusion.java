package com.example.effectivejava.chapter4.item17;

public class Conclusion {
    /*
    * 아이템 17. 변경 가능성을 최소화하라.
    * - 불변 클래스는 가변 클래스보다 설계/구현/사용이 용이하며, 예측하지 못한 버그가 발생할 여지가 적다.
    * - Thread-Safe 하다.
    * - 불변 객체는 변하지 않기 때문에 메모리에서 한 번 캐싱하면 모든 쓰레드에서 사용할 수 있다.
    * - 불변 클래스의 규칙
    *   1. 객체 상태를 변경하는 메서드를 제공하지 않음.
    *   2. 클래스를 확장할 수 없어야함.
    *   3. 모든 필드를 final/ private으로 선언해야함.
    *   4. 외부에서 내부의 참조 변수에 접근할 수 없어야함.
    * */

    /*
    * 1. 함수형 프로그래밍에 적합하다. (피연산자의 변경 X)
    * 2. 불변 객체끼리는 참조 값이여도 안전하게 공유할 수 있다.
    * 3. 정적 팩터리 메서드 내부 반환값을 캐싱해서 사용 가능함.
    * 4. final이 붙지 않아도 생성자가 private이라면 사실상 final이라고 봄
    * 5. 만약 상속이 가능한 불변 객체라면 타입을 체크해서 방어적으로 복사해야함.
    * 6. 미리 정해진 값이 아닌 메서드 호출 시에 값이 결정되는 경우 final이 아닌 필드를 선언하고 외부에 공개하지 않을 수 있다.
    * */

    private final short num = 1;
    private volatile int hashCode;

    public int hashCode() {
        if (this.hashCode !=0) {
            return hashCode;
        }

        synchronized (this) {
            int result = hashCode;
            if (result == 0) {
                result = Short.hashCode(num);
            }
            return result;
        }
    }

    /*
    * BigInteger의 경우
    * => BigInteger 내부에서 int[] mag는 변경되지 않기 때문에 안전하게 공유 가능하다.
    * 그러나, 가변 객체와 mag를 공유할 경우 불변이 망가진다.
    *
    * 연산이 실패해도 값이 변경될 우려가 없으므로 실패 원자성이 보장된다.
    * */

    /*
    * 유일한 단점.
    * 매번 새로운 객체를 생성하는데, 객체를 생성하는 값이 크다면 비용이 많이 필요할 수 있다.
    *
    * 보완하는 방법.
    * => 내부 필드에 가변 객체를 동반하되, 해당 가변 객체에 접근할 수 없게 만들고, 변경할 수 없게 한다.
    * => 그러면 모든 불변 객체가 같은 참조를 가지므로 생산 비용은 줄이고 불변은 유지할 수 있다.
    * */

    /*
    * 추가적인 불변 클래스 구현 방법
    * 1. private / package-private(default) 생성자와 정적 팩터리 메서드의 활용
    * => 이를 이용하면 불변 클래스를 확장할 수 있다.
    * => 정적 팩터리를 통해 여러 구현 클래스 중 하나늘 활용할 수 있는 유연성을 제공한다.
    * 2. 재정의가 가능한 클래스는 방어적 복사를 사용한다.
    * 3. 외부에 공개하는 필드는 모두 final이여야 한다. (반대로도 해석 가능하다.)
    * => 계산 비용이 큰 값은 해당 값이 필요로할 때 (나중에)계산하여 final이 아닌 필드에 캐시해서 사용 가능하다.
    * */

    /*
    * final <=> JMM (JLS 17.4, JLS 17.5)
    * JMM :
    *  자바 메모리 모델은 JVM이 아니라 JMM이다.
    *  Legal 프로그램 실행 규칙?
    *  메모리 모델이 허용하는 범위내에서 프로그램을 어떻게 실행하든 구현체(JVM)의 자유. (실행 순서가 바뀔 수 있음)
    * 어떤 인스턴스의 final 변수를 초기화하기 전까지 해당 인스턴스를 참조하는 모든 쓰레드는 기다려야함.
    * */

    /*
    * JMM (Java Memory Model)
    * 주어진 프로그램과 실행하는 트레이스가 있을 때
    * 실행 과정이 적합한지 알려주는 것
    * */

    /*
    * concurrent
    * => 병행 프로그래밍에 유용하게 사용할 수 있는 유틸리티 묶음
    * (병렬은 실제 동시, 병행은 번갈아가면서 작동하는 것)
    * => 병렬과 병행은 같이 사용할 수 있음.
    *
    * CountDownLatch?
    *  여러 스레드로 실행하는 여러 작업이 끝날 때까지 기다릴 때 사용
    * -> 초기화할 때 숫자를 입력하고 await()으로 숫자가 0이될 때까지 기다림.
    * -> 숫자 체크는 countDown()
    * -> 재사용 불가능. CyclicBarrier로 재생성해야.
    * -> 시작 또는 종료 신호로 사용 가능
    * */
}
